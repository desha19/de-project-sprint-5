Приветствую!

Проект был очень сложным. Прошу при найденных ошибках поподробней описать проблему.
Только в конце проекта понял, что нужно было его писать в директории "de-project-sprint-5" по этому я скопировал все файлы в эту папку.

Спасибо за фидбэк! :)

17.06.2024
Добрый день, Максим! :)

1. Максим: Все верно, но стоит добавить UNIQUE для сочетание курьер — год — месяц.
   Денис: Для таблицы cdm.dm_courier_ledger добавил ограничение по уникальности UNIQUE(courier_id, settlement_year, settlement_month).
2. Максим: Это неоптимальное решение, а на реальных данных оно не сработает. Нужно фильтровать данные на этапе получения, а не получать все, а потом сравнивать со всем, 
   что уже есть в хранилище. Инкрементальность нужно настраивать на первой из возможных стадий папйплайна. Подробнее об этом в комменте, в файле readme.
   Денис: Полностью согласен с твоим замечанием. Осознание фильтрации данных возникло после написание ДАГа, по этому реализовал в конце, 
	  а на переписывание времени не осталось. 
3. Максим: Что-то ты усложняешь, для этой витрины не нужны данные бонусов:)
    	   Витрина не должна ссылаться на stage слой.
   Денис: Теоретически, необходимые данные (product_id, order_id, "count", price) можно было бы взять из таблицы dds.fct_product_sales, 
   	  но при загрузки данными этой таблицы существует условие: WHERE ts::date BETWEEN (now() AT TIME ZONE 'utc')::date - 3 AND (now() AT TIME ZONE 'utc')::date - 1 
   	  а нам нужно построить витрину, которая будет отображать данные за предыдущий месяц, по этому она не подошла и решил, что дагов и так много, взял данные из 
   	  stg слоя из таблицы stg.bonussystem_events. Создал дополнительную таблицу fct_product_sales_cur и ДАГ для наполнением данных fct_product_sales_cur_dag. 
   	  В дальнейшем учту момент разделения по слоям (CDM -> DDS -> STG -> источник) !!!при наполнении данными текущего слоя, данные беруться из предыдущего слоя!!! :)
4. Максим: А какие объекты ты пропускаешь? В витрине агрегированные данные.
   Денис: Код из спринта я использовал, как шаблон и пропустил этот момент.
5. Максим: Ты делаешь отдельный класс для каждой таблицы просто для того, чтобы выполнить SQL запрос. Это теряет смысл использования ООП, либо написать один класс и 
   использовать его для обработки любых запросов, либо не использовать ООП. Для того, чтобы выполнить SQL запрос, точно можно обойтись без него.
   Денис: Да полностью согласен, я с ООП плохо знаком. Код взял из спринта, как шаблон и придерживался принципа: "Не трогай то, что работает." :) 
6. Максим: Не стоит делать отдельный даг для каждой таблицы, это излишне. Следует сделать по дагу на каждый слой DWH. Не говоря о том, что таблицы зависят между собой, 
   а между дагами ты связи не делаешь
   Денис: Верное замечание! Я сталкивался с проблемой при загрузке данных, когда AirFlow ругался на то, что получаются NULL-значения. В будущем это обязательно учту.

Максим, благодарю за оставленные замечания и подробное описание!!!

Вывод по важным моментам: 1) фильтровать данные нужно на этапе получения, только после этого загружать в БД; 
		          2) нужно соблюдать разделение по слоям (CDM -> DDS -> STG -> источник); 
			  3) создаём один класс и пользуемся в последующих DAGах; 
			  4) DAGи следует создать для всего слоя;
	     		  а не для каждой таблицы (компактность и сохраняются зависимости между таблицами).